{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ClassReferences/AbstractODE/","title":"Class AbstractODE","text":"<p>The class <code>AbstractODE</code> is an abstract class for ordinary differential equations (ODEs) of the form</p> \\[ \\dot{\\mathbf{x}}(t) = \\mathbf{f} (\\mathbf{x}(t), \\mathbf{u}). \\]"},{"location":"ClassReferences/AbstractODE/#attributes","title":"Attributes","text":"<ul> <li><code>_dim</code> (int): The dimension of the ODE.</li> <li><code>_param_dim</code> (int): The dimension of the parameter \\(\\mathbf{u}\\).</li> <li><code>_rhs</code> ((ndarray, ndarray) -&gt; ndarray): The right-hand side function of the ODE.   It's a mapping \\(\\mathbb{R}^{N \\times N_x} \\times \\mathbb{R}^{N \\times N_u} \\rightarrow \\mathbb{R}^{N \\times N_x}\\).</li> </ul>"},{"location":"ClassReferences/AbstractODE/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, dim, param_dim, rhs)</code></li> <li><code>rhs(self, x, u)</code>: Computes the right-hand side function using the inputs <code>(x, u)</code>. If <code>_param_dim=0</code> then <code>u</code> will be ignored.</li> </ul>"},{"location":"ClassReferences/Dictionary/","title":"Class Dictionary","text":"<p>A <code>Dictionary</code> is a vector function \\(\\Psi = (\\psi_1, \\psi_2, \\cdots, \\psi_{N_\\psi})^T\\), where \\(\\psi_i = g_i\\) for \\(i = 1,\\cdots,N_y\\) (see Approximation of Koopman). It supports batched operation \\(\\Psi: \\mathbb{R}^{N \\times N_x} \\rightarrow \\mathbb{R}^{N \\times N_{\\psi}}\\).</p>"},{"location":"ClassReferences/Dictionary/#attributes","title":"Attributes","text":"<ul> <li><code>_function</code> (ndarray -&gt; ndarray): The batched vector function   \\(\\Psi: \\mathbb{R}^{N \\times N_x} \\rightarrow \\mathbb{R}^{N \\times N_{\\psi}}\\).</li> <li><code>_dim_input</code> (int): The input dimension \\(N_x\\).</li> <li><code>_dim_output</code> (int): The output dimension \\(N_{\\psi}\\).</li> </ul>"},{"location":"ClassReferences/Dictionary/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, function, dim_input, dim_output)</code></li> <li><code>__call__(self, x)</code>: Applies the dictionary to input <code>x</code>, which must satisfy \\(x \\in \\mathbb{R}^{N \\times N_x}\\).</li> </ul>"},{"location":"ClassReferences/EDMDDLSolver/","title":"Class EDMDDLSolver","text":"<p>The class <code>EDMDDLSolver</code> implements the EDMD-DL algorithm.</p>"},{"location":"ClassReferences/EDMDDLSolver/#attributes","title":"Attributes","text":"<ul> <li><code>__regularizer</code>: The regularizer \\(\\lambda\\) used in the computation of \\(K\\).</li> </ul>"},{"location":"ClassReferences/EDMDDLSolver/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, dictionary, regularizer)</code><ul> <li><code>dictionary</code> (TrainableDictionary)</li> <li><code>regularizer</code> (float)</li> </ul> </li> <li><code>solve(self, dataset, n_epochs, batch_size, tol)</code>:    Applies the EDMD-DL algorithm to solve the system.<ul> <li><code>dataset</code> (ODEDataSet): The dataset to solve.</li> <li><code>n_epochs</code> (int): The number of epochs.</li> <li><code>batch_size</code> (int): The batch size.</li> <li><code>tol</code> (float): The tolerance of the solver.</li> <li><code>return</code> (Koopman): The Koopman operator with a neural network function.</li> </ul> </li> </ul>"},{"location":"ClassReferences/EDMDSolver/","title":"Class EDMDSolver","text":"<p>The class <code>EDMDSolver</code> implements the EDMD algorithm.</p>"},{"location":"ClassReferences/EDMDSolver/#attributes","title":"Attributes","text":"<ul> <li><code>_dictionary</code> (Dictionary): A dictionary of basis functions.</li> </ul>"},{"location":"ClassReferences/EDMDSolver/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, dictionary)</code></li> <li><code>solve(self, dataset)</code>:    Applies the EDMD algorithm to solve the system,<ul> <li><code>dataset</code> (ODEDataSet): The dataset to solve.</li> <li><code>return</code> (Koopman): The Koopman operator.</li> </ul> </li> </ul>"},{"location":"ClassReferences/FlowMap/","title":"Class FlowMap","text":"<p>The class <code>FlowMap</code> implements the flow map \\(\\varphi_t(x) := x(t), x(0) = x\\). This class serves as a base class for various numerical solvers for initial value problems (IVPs).</p>"},{"location":"ClassReferences/FlowMap/#attributes","title":"Attributes","text":"<ul> <li><code>_dt</code> (float): The time step size.</li> </ul>"},{"location":"ClassReferences/FlowMap/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, dt)</code></li> <li><code>step(self, ode, x, u)</code>:    The input <code>x</code> should be in the form \\(\\mathbb{R}^{N \\times N_x}\\),   <code>u</code> should be in the form \\(\\mathbb{R}^{N \\times N_u}\\).   Returns the next state vector <code>x</code> after the ODE step.</li> </ul>"},{"location":"ClassReferences/ForwardEuler/","title":"Class ForwardEuler","text":"<p>The class <code>ForwardEuler</code> is a subclass of FlowMap. It implements the forward Euler method</p> \\[ \\mathbf{x}(n+1) = \\mathbf{x}(n) + k \\mathbf{f}(\\mathbf{x}(n), \\mathbf{u}(n)), \\] <p>where \\(k\\) is the time step size.</p>"},{"location":"ClassReferences/ForwardEuler/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, dt)</code></li> <li><code>step(self, ode, x, u)</code>: Overrides <code>FlowMap.step()</code>.</li> </ul>"},{"location":"ClassReferences/FullConnResNet/","title":"Class FullConnResNet","text":"<p>The class <code>FullConnResNet</code> is a subclass of <code>torch.nn.Module</code>. It represents a fully-connected residual network.</p>"},{"location":"ClassReferences/FullConnResNet/#attributes","title":"Attributes","text":"<ul> <li><code>__input_layer</code> (torch.nn.Linear): The input layer.</li> <li><code>__hidden_layer</code> (torch.nn.module): The list of hidden layers.</li> <li><code>__output_layer</code> (torch.nn.Linear): The output layer.</li> </ul>"},{"location":"ClassReferences/FullConnResNet/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, input_dim=1, layer_size=[64, 64], output_dim=1, activation='tanh')</code><ul> <li><code>input_dim</code> (int): The input dimension.</li> <li><code>layer_size</code> (list): The list of hidden layer sizes.</li> <li><code>output_dim</code> (int): The output dimension.</li> <li><code>activation</code> (str): The activation function to use.</li> <li>Effects: Initialize the network, set the <code>__input_layer</code>, <code>__hidden_layer</code>, and <code>__output_layer</code>.</li> </ul> </li> <li><code>forward(self, inputs)</code>: Applies the network to the input <code>inputs</code>, which must be in the form \\(\\mathbb{R}^{N \\times N_x}\\).</li> </ul>"},{"location":"ClassReferences/Koopman/","title":"Class Koopman","text":"<p>The class <code>Koopman</code> is a mapping \\(K: \\mathrm{span}(\\Psi) \\rightarrow \\mathrm{span}(\\Psi)\\),  which acts as the finite-dimensional approximation of the Koopman operator \\(\\mathcal{K}\\), i.e.,</p> \\[ \\mathcal{K} \\Psi \\approx K \\Psi. \\]"},{"location":"ClassReferences/Koopman/#attributes","title":"Attributes","text":"<ul> <li><code>_func</code>: The mapping \\(K: \\mathrm{span}(\\Psi) \\rightarrow \\mathrm{span}(\\Psi)\\),   which can be either a matrix or a neural network.</li> </ul>"},{"location":"ClassReferences/Koopman/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, func)</code></li> <li><code>__call__(self, x)</code>: Applies the Koopman operator,   <code>x</code> should satisfy \\(x \\in \\mathbb{R}^{N \\times N_{\\psi}}\\).</li> </ul>"},{"location":"ClassReferences/ODEDataSet/","title":"Class ODEDataSet","text":"<p>The class <code>ODEDataSet</code> is a subclass of <code>torch.utils.data.Dataset</code>, it provides data for <code>EDMDSolver</code>, <code>EDMDDLSolver</code> and <code>ParamKoopmanDLSolver</code>.</p>"},{"location":"ClassReferences/ODEDataSet/#attributes","title":"Attributes","text":"<ul> <li><code>__ode</code> (AbstractODE): The ODE system.</li> <li><code>__flowmap</code> (FlowMap): The flow map of the ODE system.</li> <li><code>__data_x</code> (ndarray): The state data of the system.</li> <li><code>__data_param</code> (ndarray): The parameter data of the system.</li> <li><code>__labels</code> (ndarray): The label data of the system.</li> </ul>"},{"location":"ClassReferences/ODEDataSet/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, ode, flowmap)</code></li> <li><code>__len__(self)</code>: Returns the number of dataset.</li> <li><code>__getitem__(self, idx)</code>: Returns the data at index <code>idx</code>, including <code>x</code>, <code>param</code> and <code>label</code>.</li> <li><code>generate_data(self, n_traj, traj_len, x_min, x_max, param_min, param_max, seed_x=11, seed_param=22)</code><ul> <li><code>n_traj</code> (int): The number of trajectories to generate.</li> <li><code>traj_len</code> (int): The length of each trajectory.</li> <li><code>x_min</code>, <code>x_max</code> (float): The range of the initial state.</li> <li><code>param_min</code>, <code>param_max</code> (float): The range of the parameter.</li> <li><code>seed_x</code>, <code>seed_param</code> (int): The seed for the random number generator.</li> <li>Effects: Generate data and store in <code>self.__data_x</code>, <code>self.__data_param</code> and <code>self.__labels</code>.</li> </ul> </li> </ul>"},{"location":"ClassReferences/ParamKoopman/","title":"Class ParamKoopman","text":"<p>The class <code>ParaKoopman</code> is a subclass of Koopman. It represents a mapping \\(K: \\mathrm{span}(\\Psi) \\times U \\rightarrow \\mathrm{span}(\\Psi)\\), which is a finite-dimensional approximation of the parametric Koopman operator.</p>"},{"location":"ClassReferences/ParamKoopman/#attributes","title":"Attributes","text":"<ul> <li><code>_func</code>: Inherited from <code>Koopman</code>, it's a mapping   \\(K: \\mathrm{span}(\\Psi) \\times U \\rightarrow \\mathrm{span}(\\Psi)\\),   here we assume \\(U = \\mathbb{R}^{N_u}\\).</li> </ul>"},{"location":"ClassReferences/ParamKoopman/#methods","title":"Methods","text":"<ul> <li><code>__call__(self, x, para)</code>: Applies the parametric Koopman operator on <code>(x, para)</code>,   which should satisfy \\(x \\in \\mathbb{R}^{N \\times N_{\\psi}}\\),   \\(\\text{para} \\in \\mathbb{R}^{N_u}\\).</li> </ul>"},{"location":"ClassReferences/ParamKoopmanDLSolver/","title":"Class ParamKoopmanDLSolver","text":"<p>The class <code>ParaKoopmanDLSolver</code> implements the algorithm of learning parametric Koopman decompositions.</p>"},{"location":"ClassReferences/ParamKoopmanDLSolver/#attributes","title":"Attributes","text":"<ul> <li><code>__dictionary</code> (TrainableDictionary)</li> </ul>"},{"location":"ClassReferences/ParamKoopmanDLSolver/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, dictionary)</code></li> <li><code>solve(self, dataset, n_epochs, batch_size, tol)</code>:<ul> <li><code>dataset</code> (ODEDataSet): The dataset to solve.</li> </ul> </li> </ul>"},{"location":"ClassReferences/TrainableDictionary/","title":"Class TrainableDictionary","text":"<p>A <code>TrainableDictionary</code> is a subclass of Dictionary. It contains a trainable neural network and \\(N_y\\) non-trainable outputs, mapping \\(\\Psi: \\mathbb{R}^{N \\times N_x} \\rightarrow \\mathbb{R}^{N \\times N_{\\psi}}\\).</p>"},{"location":"ClassReferences/TrainableDictionary/#attributes","title":"Attributes","text":"<ul> <li><code>__dim_nontrain</code> (int): The number of non-trainable outputs.</li> <li><code>__network</code> (torch.nn.Module): The trainable neural network.</li> </ul> <p>Info</p> <p>The attribute <code>_function</code>, inherited from <code>Dictionary</code>, is a function that combines the neural network with non-trainable outputs. The first <code>dim_nontrain</code> outputs are non-trainable.</p>"},{"location":"ClassReferences/TrainableDictionary/#methods","title":"Methods","text":"<ul> <li><code>__init__(self, network, nontrain_func, dim_input, dim_output, dim_nontrain)</code><ul> <li><code>network</code> (torch.nn.Module): The trainable neural network,   which is a mapping \\(\\Psi: \\mathbb{R}^{N \\times N_x} \\rightarrow \\mathbb{R}^{N \\times (N_{\\psi} - N_y)}\\). </li> <li><code>nontrain_func</code> (ndarray -&gt; ndarray): The trainable neural network,   which is a mapping \\(\\Psi: \\mathbb{R}^{N \\times N_x} \\rightarrow \\mathbb{R}^{N \\times N_y}\\).</li> <li><code>dim_input</code> (int): The dimension of the input \\(N_x\\).</li> <li><code>dim_output</code> (int): The dimension of the output \\(N_{\\psi}\\).</li> <li><code>dim_nontrain</code> (int): The number of non-trainable outputs \\(N_y\\).</li> </ul> </li> <li><code>parameters(self)</code>: Return the trainable parameters of the network <code>__network</code>.</li> </ul>"},{"location":"Mathematics/ApproxKoopman/","title":"Finite-dimensional Approximation of Koopman","text":""},{"location":"Mathematics/ApproxKoopman/#numerical-methods-for-autonomous-dynamics","title":"Numerical Methods for Autonomous Dynamics","text":"<p>Consider the autonomous (non-parametric) dynamical systems of the form</p> \\[ \\begin{align*} \\mathbf{x}_{n+1} &amp;= \\mathbf{f}(\\mathbf{x}_n),\\\\ \\mathbf{y}_n &amp;= \\mathbf{g}(\\mathbf{x}_n), \\end{align*} \\] <p>where \\(\\mathbf{g}\\) is a length-\\(N_y\\) vector of \\(L^2\\) observable functions \\(\\mathbf{y}\\). The goal is to find a finite-dimensional subspace \\(H \\subset L^2\\) that contains the components of \\(\\mathbf{g}\\), and moreover is invariant under the action of the Koopman operator, i.e.,</p> \\[ \\mathcal{K}(H) \\subset H, \\] <p>at least approximately.</p> <p>We build \\(H\\) as the span of a set of dictionary functions \\(\\{\\psi_1,\\psi_2,\\cdots,\\psi_{N_{\\psi}}\\}\\) where \\(\\psi_i \\in L^2(X, m)\\), with \\(\\psi_i = g_i\\) for \\(i = 1,2,\\cdots,N_y\\). Let we write \\(\\Psi := (\\psi_1,\\psi_2,\\cdots,\\psi_{N_{\\psi}})^T\\), and consider the subspace \\(\\mathrm{span}(\\Psi) = \\left\\{ a^T\\Psi: a \\in \\mathbb{R}^{N_{\\psi}} \\right\\}\\). If we assume \\(\\mathcal{K}(\\mathrm{span}(\\Psi)) \\subset \\mathrm{span}(\\Psi)\\), then \\(\\mathcal{K}\\) can be considered as a linear transformation in \\(\\mathrm{span}(\\Psi)\\). Thus \\(\\mathcal{K}\\) can be represented by a matrix \\(K \\in \\mathbb{R}^{N_{\\psi} \\times \\mathbb{R}^{N_{\\psi}}}\\), satisfying</p> \\[ \\mathcal{K} \\Psi  = K \\Psi. \\] <p>From a data science perspective, we collect data pairs \\(\\{(\\mathbf{x}_{n+1}^{(m)}, \\mathbf{x}_n^{(m)})\\}_{n,m=0}^{N-1,M-1}\\), where \\(\\mathbf{x}_{n+1}^{(m)} = \\mathbf{f} (\\mathbf{x}_n^{(m)})\\) and \\(\\mathbf{x}_n^{(m)}\\) is the state on the \\(m\\)th trajectory at time \\(n\\). Then, an approximation of the Koopman operator on this subspace is computed via least squares</p> \\[ \\hat{K} =  \\operatorname*{argmin}_{K \\in \\mathbb{R}^{N_{\\psi} \\times N_{\\psi}}} \\sum\\limits_{n,m = 0}^{N-1,M-1} \\|\\Psi(\\mathbf{x}_{n+1}^{(m)}) - K \\Psi(\\mathbf{x}_n^{(m)})\\|^2.\\] <p>The solution is guaranteed to be unique when the number of data pairs is at least equal to or larger than the dimension of the dictionary \\(\\Psi\\).</p>"},{"location":"Mathematics/ApproxKoopman/#numerical-methods-for-parametric-dynamics","title":"Numerical Methods for Parametric Dynamics","text":"<p>Consider the parametric dynamics</p> \\[ \\begin{align*} \\mathbf{x}_{n+1} &amp;= \\mathbf{f}(\\mathbf{x}_n, \\mathbf{u}_n),\\\\ \\mathbf{y}_n &amp;= \\mathbf{g}(\\mathbf{x}_n). \\end{align*} \\]"},{"location":"Mathematics/ParamKoopman/","title":"Parametric Koopman","text":""},{"location":"Mathematics/ParamKoopman/#parametric-dynamical-systems","title":"Parametric Dynamical Systems","text":"<p>Let \\((X, \\mathcal{S}, m)\\), with \\(X \\subseteq \\mathbb{R}^{N_x}\\) be a finite measure space where \\(\\mathcal{S}\\) is the Borel \\(\\sigma\\)-algebra and \\(m\\) is a measure on \\((X, \\mathcal{S})\\). Consider a set \\(U \\subseteq \\mathbb{R}^{N_u}\\) of parameters, and the parametric discrete-time dynamics</p> \\[ \\mathbf{x}_{n+1} = \\mathbf{f}(\\mathbf{x}_n, \\mathbf{u}), \\quad n = 0,1,\\cdots \\] <p>where \\(\\mathbf{u} \\in U\\) remains static, or control systems</p> \\[ \\mathbf{x}_{n+1} = \\mathbf{f}(\\mathbf{x}_n, \\mathbf{u}_n), \\quad n = 0,1,\\cdots, \\] <p>where \\(\\mathbf{u}_n \\in U\\) changes in discrete steps dynamically.</p>"},{"location":"Mathematics/ParamKoopman/#parametric-koopman-operator","title":"Parametric Koopman Operator","text":"<p>Definition. Consider the Hilber space</p> \\[ L^2(X, m) = \\left\\{ \\phi: X \\rightarrow \\mathbb{R}: \\|\\phi\\|_{L^2(X, m)} &lt; \\infty \\right\\}. \\] <p>An element \\(\\phi \\in L^2(X, m)\\) is called an observable.</p> <p>Definition. The parametric Koopman operator maps an observable \\(\\phi \\in L^2(X, m)\\) to another observable \\(\\mathcal{K}\\phi\\) defined by:</p> \\[ \\mathcal{K}(\\mathbf{u}) \\phi(\\mathbf{x}) := \\phi \\circ \\mathbf{f}(\\mathbf{x}, \\mathbf{u}). \\]"}]}